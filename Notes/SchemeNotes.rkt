(define my-name '(unknown))
(set! my-name '(Kristie))

;my-name = Kristie

(not #t) ;#f

;printing
(display '(hello this is a print statement))

;primitive expression = cannot be broken down further

;procedure > function


;assignment operator
;in Java:  =
;in Scheme: set!

;applicative-order - fully-define/eval all parameters before running body of func
;normal-order - eval/define only when parameter called
	;- used in some special forms (if)

(define p 23) ;define variable
(define (p) (parameters)) ;define function


;recursive (+ (f) (f))
; cant be written as loop
; has to wait for both fs to finish running before adding. takes along time
; expands and contracts
; do not keep track of parameters

;iterative
; can be written as loop
; faster, less memory
; will always return same value no matter where in the loop u are
; keep track of state of proces at all times

;tail recursive = could have been written as a loop = iterative

;order of growth
; time vs input size
; linear > exponential order of growth!!!! much faster
; coefficient of lead term does not matter
;order of growth = how many times the func is being called
;recursive/iterative diff
;O(1) constant for linear iterative
;O(n) linear recursive

(trace func) ;shows all lines of intermediary code

(if expr #t #f)
; if expr is true, return #t. if not, return #f