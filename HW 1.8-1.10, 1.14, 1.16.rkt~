;1.8 - cube-root procedure
(define (cube x) (* x x x))

;(define (improve guess x)
;  (average guess (/ x guess)))

(define (improve x y)
  (/ (+ (/ x (* y y)) (* 2 y)) 3))

(define (good-enough guess x)
  (< (abs (- (cube guess) x)) 0.001))

;if the diff between /guess of cube of cbrt x/ and x is less than .001, then good enough = true

(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))

; nEW IF OR IF??
(define (cbrt-iter guess x)
  (new-if (good-enough guess x)
          guess ;guess was already the answer, return guess
          (cbrt-iter (improve guess x)
                     x)))





;1.9
(define (dec x) (- x 1))
(define (inc x) (+ 1 x))

(define (add a b)
  (if (= a 0)
      b
      (inc (add (dec a) b))))
;(add 4 5)
;(+ 1 (add (dec 4) 5) )
;(+ 1 (add (3) 5) )
;(+ 1 (add (+ 1 (add 2 5))) )
;(+ 1 (add (+ 1 (+ 1(add 1 5)))) )
;(+ 1 (add (+ 1 (+ 1(+ 1 (0 5))))) )
;(+ 1 (add (+ 1 (+ 1(+ 1 (5 5))))) )


(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
;processes are recursive

;(+ 4 5)
;(





;1.10 - Ackermann's function
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))
    )
  )
;(A 1 10) ->
;A 0 (A 1 9)
;A 0 (A 0 (A 1 8))
;A 0 (A 0 (A 0 (A 1 7)))
;A 0 (A 0 (A 0 (A 0 (A 1 6))))
;..........(A 1 0)
;... returns 1024

;(A 2 4) -> 65536
;(A 3 3) -> 65536

(define (f n) (A 0 n))
;2n

(define (g n) (A 1 n))
;(A 1 n)
;(A 0 (A 1 n-1))
;(A 0 (A 0 (A 1 n-2)))
;expands n times, then 2 * 2^(n-1)

;2^n

(define (h n) (A 2 n))  ;?????
;(A 2 n)
;(A 2 3)
;(A 1 (A 2 2))
;(A 1 (A 1 (A 2 1)))
;(A 1 (A 1 2))
;(A 1 (A 0 (A 1 1)))
;(A 1 (A 0 (2)))
;(A 1 4)
;(A 0 (A 1 (3)))
;expands until y=1; 2. n times
;n times of 2

;2^(2^(n-1))

(define (k n) (* 5 n n))
;5n^2


;1.14 by hand

;1.16 extra credit â€“ write fast-expt iteratively
;(define (fast-iter-expt num count max-count)

;  )




